<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Shadow Path â€“ Konva åŸºç¤ç‰ˆï¼ˆGrid / è§’è‰²ç§»å‹• / ç‰† / å·è»¸ / å¤–æ¡†ï¼‰</title>
  <style>
/* === é é¢æ•´é«”è¨­å®š === */
body {
  margin: 0; /* ç§»é™¤é è¨­å¤–è·ï¼Œè®“ç•«é¢é ‚æ»¿è¦–çª— */
  background: #1b1b1b; /* æ•´é«”èƒŒæ™¯ç‚ºæ·±ç°è‰²ï¼ˆé»‘ç¶ èª¿ï¼‰ */
  color: #d8ffd6; /* é è¨­æ–‡å­—é¡è‰²ç‚ºæ·¡è¢å…‰ç¶  */
  font-family: ui-sans-serif, system-ui, "Noto Color Emoji", 
               "Apple Color Emoji", "Segoe UI Emoji", Arial; 
  /* ä½¿ç”¨ç³»çµ±ç„¡è¥¯ç·šå­—å‹ï¼Œæ”¯æ´ emoji é¡¯ç¤º */

  display: flex;           /* ä½¿ç”¨ flex æ’ç‰ˆï¼Œæ–¹ä¾¿æ©«å‘æ’åˆ—é¢æ¿ */
  gap: 16px;               /* å„é¢æ¿ä¹‹é–“é–“è· 16px */
  flex-wrap: wrap;         /* è‡ªå‹•æ›è¡Œï¼Œé¿å…è¦–çª—å¤ªçª„æ™‚æ“ å‡ºç•«é¢ */
  justify-content: center; /* å…§å®¹ç½®ä¸­å°é½Š */
  padding: 18px;           /* é é¢å…§é‚Šè· */
}

/* === é¢æ¿é€šç”¨æ¨£å¼ === */
.panel {
  background: #0f172a;               /* æ·±è—åº•è‰²ï¼Œé¡ä¼¼å¤œè‰²é›»è·¯æ„Ÿ */
  border: 1px solid #1f2937;         /* å¤–æ¡†é¡è‰²è¼ƒæ·ºï¼Œå½¢æˆé‚Šç•Œ */
  border-radius: 12px;               /* åœ“è§’é‚Šæ¡† */
  padding: 12px;                     /* å…§è·ï¼Œè®“å…§å®¹ä¸ç·Šè²¼é‚Šç•Œ */
  box-shadow: 0 8px 20px rgba(0,0,0,.3); /* ä¸‹æ–¹é™°å½±ï¼Œå¢ç«‹é«”æ„Ÿ */
}

/* === Konva ç•«å¸ƒèˆå°å®¹å™¨ === */
#stage {
  border: 1px solid #20d25a; /* ä½¿ç”¨è¢å…‰ç¶ é‚Šæ¡†å‘¼æ‡‰éŠæˆ²ä¸»é¡Œè‰² */
  border-radius: 12px;       /* èˆ‡é¢æ¿ä¸€è‡´çš„åœ“è§’ */
  overflow: hidden;          /* éš±è—è¶…å‡ºç¯„åœçš„ç¹ªåœ–å…§å®¹ */
}

/* === éµç›¤æç¤ºæ–‡å­—ï¼ˆkbd å…ƒç´ ï¼‰ === */
kbd {
  background: #0b1220;         /* éµå¸½èƒŒæ™¯ï¼šæ·±è—é»‘ */
  border: 1px solid #1f2937;   /* é‚Šæ¡†é¡è‰²åŒ panelï¼Œç•¥é¡¯ç«‹é«” */
  border-bottom-width: 2px;    /* åº•é‚Šç•¥åšï¼Œæ¨¡æ“¬éµå¸½é™°å½± */
  padding: 1px 6px;            /* å…§è·è®“æ–‡å­—ä¸è²¼é‚Š */
  border-radius: 6px;          /* åœ“è§’é‚Šæ¡† */
}

/* === æ¬¡è¦æ–‡å­—ï¼ˆè¨»è§£ã€èªªæ˜ç”¨ï¼‰ === */
.note {
  color: #9aa4b2; /* æ·ºç°è—è‰²ï¼Œç”¨æ–¼è¼”åŠ©èªªæ˜æ–‡å­— */
}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/konva@9/konva.min.js"></script>
</head>
<body>
  <div class="panel">
    <div style="font-weight:600;margin-bottom:6px">Shadow Path â€“ Konva æ ¸å¿ƒéª¨æ¶</div>
    <div class="note">ä¸»é¡Œï¼šé‡‘å±¬ç°åº• + è¢å…‰ç¶ ç·šï¼ˆé›»è·¯æ„Ÿï¼‰ã€‚<br/>æ§åˆ¶ï¼šğŸ¥· æ–¹å‘éµã€ğŸ‘® WASDã€‚ç‰†é«”ğŸ§±ä¸å¯é€šè¡Œï¼›ğŸ“œ ç‚ºç›®æ¨™ã€‚<br/>ç¯„ä¾‹ä¸­ç¤ºç¯„äº† drawRegionOutline() åªç•«å‡ºç¯„åœå¤–æ¡†çš„åŠŸèƒ½ã€‚</div>
  </div>
  <div id="stage" class="panel"></div>

<script>
// ====== åŸºæœ¬è¨­å®š ======
const COLS = 20, ROWS = 20, CELL = 40;
const STAGE_W = COLS * CELL, STAGE_H = ROWS * CELL;

const COLOR_BG = '#444';
const COLOR_GRID = '#0aa84a';
const COLOR_GRID_BOLD = '#27ff7e';

const NINJA = 'ğŸ¥·', COP = 'ğŸ‘®', WALL = 'ğŸ§±', SCROLL = 'ğŸ“œ';

const walls = [ [2,2],[2,3],[2,4],[6,5],[7,5],[8,5],[5,7],[5,8] ];
const scrollPos = { x:4, y:6 };

// === è§’è‰²åˆå§‹è¨­å®šï¼ˆä½¿ç”¨ r ä»£è¡¨æœå‘ï¼‰ ===
const ninja = { id:'ninja', x:1, y:8, r:0, emoji:NINJA, color:'#0ff' };
const cop   = { id:'cop',   x:8, y:1, r:0, emoji:COP,   color:'#f0f' };

const stage = new Konva.Stage({ container:'stage', width:STAGE_W, height:STAGE_H });
const gridL   = new Konva.Layer({ listening:false });
const propsL  = new Konva.Layer();
const unitsL  = new Konva.Layer();
const overlayL= new Konva.Layer({ listening:false });
stage.add(gridL, propsL, unitsL, overlayL);

function inBounds(x,y){ return x>=0 && x<COLS && y>=0 && y<ROWS; }
function cellRect(x,y){ return { x:x*CELL, y:y*CELL, w:CELL, h:CELL }; }
function isWall(x,y){ return walls.some(([wx,wy])=> wx===x && wy===y); }
function occupiedByUnit(x,y){ return (x===ninja.x && y===ninja.y) || (x===cop.x && y===cop.y); }

function tryMove(unit, dx, dy){
  const nx = unit.x + dx, ny = unit.y + dy;
  if(!inBounds(nx,ny)) return;
  if(isWall(nx,ny)) return;
  if(occupiedByUnit(nx,ny)) return;
  unit.x = nx; unit.y = ny;
}

function facingToAngle(f){ return f==='E'?0 : f==='S'?90 : f==='W'?180 : -90; }

// ====== å€åŸŸå¤–æ¡†ï¼šåƒ…æç¹ªæ¥å£¤å¤–éƒ¨çš„é‚Š ======
function drawRegionOutline(cells, options={}){
  const color = options.color || '#ff3b3b';
  const width = options.width || 3;
  const set = new Set(cells.map(([x,y])=>`${x},${y}`));
  function has(x,y){ return set.has(`${x},${y}`); }
  for(const [x,y] of cells){
    const x0=x*CELL, y0=y*CELL, x1=(x+1)*CELL, y1=(y+1)*CELL;
    if(!has(x, y-1)) overlayL.add(new Konva.Line({ points:[x0,y0, x1,y0], stroke:color, strokeWidth:width, lineCap:'round' }));
    if(!has(x+1, y)) overlayL.add(new Konva.Line({ points:[x1,y0, x1,y1], stroke:color, strokeWidth:width, lineCap:'round' }));
    if(!has(x, y+1)) overlayL.add(new Konva.Line({ points:[x0,y1, x1,y1], stroke:color, strokeWidth:width, lineCap:'round' }));
    if(!has(x-1, y)) overlayL.add(new Konva.Line({ points:[x0,y0, x0,y1], stroke:color, strokeWidth:width, lineCap:'round' }));
  }
  overlayL.batchDraw();
}

function buildCrossRegion(cx,cy,r=2){
  const cells=[];
  for(let dy=-r; dy<=r; dy++){
    for(let dx=-r; dx<=r; dx++){
      if(Math.abs(dx)===r && Math.abs(dy)===r) continue; // å»é™¤å››è§’
      const x=cx+dx, y=cy+dy;
      if(inBounds(x,y)) cells.push([x,y]);
    }
  }
  return cells;
}



let hoverRect = null;
let selectRect = null;

// å–å¾—æ ¼åº§æ¨™
function getCellFromPointer(pos){
  const x = Math.floor(pos.x / CELL);
  const y = Math.floor(pos.y / CELL);
  return {x, y};
}

// æ»‘é¼ ç§»å‹•
stage.on('mousemove', (e)=>{
  const pos = stage.getPointerPosition();
  const {x, y} = getCellFromPointer(pos);

  if (!inBounds(x,y)) return;

  // è‹¥é‚„æ²’å»ºç«‹ hoverRect å°±å»ºä¸€å€‹
  if (!hoverRect){
    hoverRect = new Konva.Rect({
      stroke: '#ff0',
      strokeWidth: 2,
      width: CELL, height: CELL,
      listening: false
    });
    overlayL.add(hoverRect);
  }

  hoverRect.position({x: x*CELL, y: y*CELL});
  overlayL.batchDraw();
});

// é»é¸æ ¼å­
stage.on('click', (e)=>{
  const pos = stage.getPointerPosition();
  const {x, y} = getCellFromPointer(pos);

  if (!inBounds(x,y)) return;

  // å¦‚æœæ²’æœ‰ selectRect å°±å»ºç«‹
  if (!selectRect){
    selectRect = new Konva.Rect({
      stroke: '#ff0',
      strokeWidth: 3,
      shadowColor: '#ff0',
      cornerRadius: 3,       // å¯é¸ï¼šåœ“è§’
      shadowBlur: 8,
      shadowOpacity: 0.8,
      width: CELL, height: CELL,
      listening: false
    });
    overlayL.add(selectRect);
  }

  selectRect.position({x: x*CELL, y: y*CELL});
  overlayL.batchDraw();
});


// æš—å¹•å±¤ï¼ˆæœ€ä¸Šå±¤ï¼‰ï¼Œåº•ä¸‹ä¸€åˆ‡æœƒè®Šæš—
const darknessL = new Konva.Layer({ listening:false });
const darkRect = new Konva.Rect({
  x:0, y:0, width: STAGE_W, height: STAGE_H,
  fill: 'rgba(0,0,0,0.2)', listening:false
});
darknessL.add(darkRect);
stage.add(darknessL);

// å¯é¸ï¼šäº®å€æŸ”å…‰å±¤ï¼ˆåœ¨æš—å¹•ä¸Šæ–¹ï¼‰
const glowL = new Konva.Layer({ listening:false });
stage.add(glowL);

function drawLighting(litCells){
  // æ¸…æ‰èˆŠå­”æ´
  darknessL.find('.hole').forEach(n => n.destroy());
  glowL.destroyChildren();

  // 1) æš—å¹•ä¸ŠæŒ–å­”ï¼ˆä¸€å®šè¦æœ‰ fill æ‰æœƒçœŸæ­£ç•«åƒç´ ï¼‰
  for (const [x, y] of litCells){
    const hole = new Konva.Rect({
      x: x * CELL,
      y: y * CELL,
      width: CELL,
      height: CELL,
      // cornerRadius: 10,
      fill: 'black',                      // â† åŠ ä¸Šé€™è¡Œï¼ˆé¡è‰²ç„¡æ‰€è¬‚ï¼‰
      globalCompositeOperation: 'destination-out',
      name: 'hole',
      listening: false
    });
    darknessL.add(hole);
  }
  darknessL.batchDraw();

  // 2) å¯é¸ï¼šäº®å€æŸ”å…‰ï¼ˆåœ¨æš—å¹•ä¸Šæ–¹çš„ glowLï¼‰
  for (const [x, y] of litCells){
    glowL.add(new Konva.Rect({
      x: x * CELL,
      y: y * CELL,
      width: CELL,
      height: CELL,
      fill: 'rgba(255,255,255,.2)',
      listening: false
    }));
  }

  // for (const [x, y] of litCells){
  //   glowL.add(new Konva.Rect({
  //     x: x * CELL,
  //     y: y * CELL,
  //     width: CELL,
  //     height: CELL,
  //     listening: false,
  //     // === æ”¾å°„æ¼¸å±¤è¨­å®š ===
  //     fillRadialGradientStartPoint: { x: CELL/2, y: CELL/2 },
  //     fillRadialGradientStartRadius: 0,
  //     fillRadialGradientEndPoint: { x: CELL/2, y: CELL/2 },
  //     fillRadialGradientEndRadius: CELL  ,  // å…‰æšˆç¯„åœï¼Œå¯èª¿ 0.6~1.0
  //     fillRadialGradientColorStops: [
  //       0.0, 'rgba(255,255,150,0.0)',   // ä¸­å¿ƒå¼·å…‰
  //       0.8, 'rgba(255,255,150,0.3)',  // ä¸­é–“æŸ”
  //       1.0, 'rgba(255,255,255,1.0)'    // é‚Šç·£é€æ˜
  //     ]
  //   }));
  // }
  glowL.batchDraw();
}


// === æ¸¬è©¦å¹¾å€‹äº®æ ¼ï¼ˆåœ¨è­¦è¡›é™„è¿‘ï¼‰ ===
const litCells = [
  [2,2],[3,3],[3,2],[2,3],
  [cop.x, cop.y],           // è‡ªå·±é‚£æ ¼
  [cop.x+1, cop.y],         // å³é‚Š
  [cop.x, cop.y+1],         // ä¸‹é‚Š
  [cop.x-1, cop.y],         // å·¦é‚Š
  [cop.x, cop.y-1],         // ä¸Šé‚Š
  [cop.x+1, cop.y+1]        // å³ä¸‹è§’
];

// åŸ·è¡Œæ¸¬è©¦
drawLighting(litCells);

// ====== ç¹ªè£½é›™æ–¹è¦–è¦ºç¯„åœ ======
function drawAllFOV(){
  overlayL.destroyChildren();

  // === è­¦è¡› FOVï¼ˆç´…è‰²ï¼‰ ===
  const guardCells = computeFOVHard(
    cop.x,       // ä¸­å¿ƒ x
    cop.y,       // ä¸­å¿ƒ y
    cop.r,       // é¢å‘æ–¹å‘ r (0~7)
    90,          // è¦–é‡å¤¾è§’ (ä¾‹ï¼š90Â°)
    4,           // è¦–è· (å¯ä¾è§’è‰²èª¿æ•´)
    {
      isBlocked: (x,y) => isWall(x,y) || occupiedByUnit(x,y),
      includeOpaqueCell: true,
      includeStart: false
    }
  );
  drawRegionOutline(guardCells, { color:'#f0f', width:1.5 });

  // === å¿è€… FOVï¼ˆé’è‰²ï¼‰ ===
  const ninjaCells = computeFOVHard(
    ninja.x,
    ninja.y,
    ninja.r,
    45,
    6,
    {
      isBlocked: (x,y) => isWall(x,y) || occupiedByUnit(x,y),
      includeOpaqueCell: true,
      includeStart: false
    }
  );
  drawRegionOutline(ninjaCells, { color:'#0ff', width:1.5 });
}

function drawGrid(){
  gridL.add(new Konva.Rect({ x:0, y:0, width:STAGE_W, height:STAGE_H, fill:COLOR_BG }));
  for(let r=0;r<=ROWS;r++){
    gridL.add(new Konva.Line({ points:[0, r*CELL, STAGE_W, r*CELL], stroke:(r%5===0?COLOR_GRID_BOLD:COLOR_GRID), strokeWidth:1 }));
  }
  for(let c=0;c<=COLS;c++){
    gridL.add(new Konva.Line({ points:[c*CELL, 0, c*CELL, STAGE_H], stroke:(c%5===0?COLOR_GRID_BOLD:COLOR_GRID), strokeWidth:1 }));
  }
  gridL.draw();
}

function drawWalls(){
  walls.forEach(([x,y])=>{
    const {x:cx,y:cy} = cellRect(x,y);
    propsL.add(new Konva.Text({ x:cx, y:cy, width:CELL, height:CELL, align:'center', verticalAlign:'middle', text:WALL, fontSize:CELL*0.66 }));
  });
}

function drawScroll(){
  const {x,y} = scrollPos; const {x:cx,y:cy} = cellRect(x,y);
  propsL.add(new Konva.Text({ x:cx, y:cy, width:CELL, height:CELL, align:'center', verticalAlign:'middle', text:SCROLL, fontSize:CELL*0.6 }));
}

function makeUnitGroup(u){
  const g = new Konva.Group({ x:u.x*CELL, y:u.y*CELL, name:'unit', id:u.id });
    // â˜… ç²—æ¡†ï¼ˆè·Ÿéš¨æ¡†ï¼‰ï¼šæ”¾åœ¨ group å…§ï¼Œæ°¸é è·Ÿè‘—è§’è‰²
  console.log(u.color)
  const followFrame = new Konva.Rect({
    x: 0,
    y: 0,
    width: CELL,
    height: CELL,
    stroke: u.color,       // ç”¨è§’è‰²è‰²æˆ–éšŠä¼è‰²
    strokeWidth: 3,      // ç²—ä¸€é»
    cornerRadius: 3,       // å¯é¸ï¼šåœ“è§’
    listening: false,      // ä¸åƒäº‹ä»¶
    shadowColor: u.color,  // å¯é¸ï¼šåšé»å…‰æšˆ
    shadowBlur: 4,
    shadowOpacity: 0.6
  });

  const hit = new Konva.Rect({ width:CELL, height:CELL, opacity:0 });
  const label = new Konva.Text({ x:0, y:0, width:CELL, height:CELL, align:'center', verticalAlign:'middle', text:u.emoji, fontSize:CELL*0.66 });
  g.add(followFrame,hit, label);

  g.cache();
  return g;
}

const ninjaGroup = makeUnitGroup(ninja);
const copGroup   = makeUnitGroup(cop);
unitsL.add(ninjaGroup, copGroup);

function updateUnit(u, group){
  group.position({ x:u.x*CELL, y:u.y*CELL });
}

drawGrid();
drawWalls();
drawScroll();
propsL.draw();
unitsL.draw();
// åˆå§‹ç¹ªè£½é›™æ–¹è¦–è¦ºç¯„åœ
drawAllFOV();

window.addEventListener('keydown', (e)=>{
  const k = e.key.toLowerCase();
  let moved = false;

// === å¿è€…ï¼ˆæ–¹å‘éµæ§åˆ¶ï¼‰ ===
if (e.key === 'ArrowLeft') {
  ninja.r = 4;                     // W (å·¦)
  tryMove(ninja, -1, 0); moved = true;
}
else if (e.key === 'ArrowRight') {
  ninja.r = 0;                     // E (å³)
  tryMove(ninja,  1, 0); moved = true;
}
else if (e.key === 'ArrowUp') {
  ninja.r = 6;                     // N (ä¸Š)
  tryMove(ninja,  0,-1); moved = true;
}
else if (e.key === 'ArrowDown') {
  ninja.r = 2;                     // S (ä¸‹)
  tryMove(ninja,  0, 1); moved = true;
}

// === å®ˆè¡›ï¼ˆWASD æ§åˆ¶ï¼‰ ===
if (k === 'a') {
  cop.r = 4;                       // W (å·¦)
  tryMove(cop, -1, 0); moved = true;
}
else if (k === 'd') {
  cop.r = 0;                       // E (å³)
  tryMove(cop,  1, 0); moved = true;
}
else if (k === 'w') {
  cop.r = 6;                       // N (ä¸Š)
  tryMove(cop,  0,-1); moved = true;
}
else if (k === 's') {
  cop.r = 2;                       // S (ä¸‹)
  tryMove(cop,  0, 1); moved = true;
}

  if(moved){
    updateUnit(ninja, ninjaGroup);
    updateUnit(cop,   copGroup);
    unitsL.batchDraw();
    drawAllFOV();
  }
});


// ---- è§’åº¦å·¥å…· ----
const DEG2RAD = Math.PI / 180;
function normAngleRad(a){ return Math.atan2(Math.sin(a), Math.cos(a)); }

// ---- èµ·é»->çµ‚é»çš„æ•´æ•¸æ ¼è·¯å¾‘ï¼ˆä¸å«èµ·é»ï¼Œå«çµ‚é»ï¼‰----
function lineCells(x0, y0, x1, y1){
  const cells = [];
  let dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
  let dy = -Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
  let err = dx + dy, x = x0, y = y0;
  while (true){
    if (!(x === x0 && y === y0)) cells.push([x, y]);
    if (x === x1 && y === y1) break;
    const e2 = 2 * err;
    if (e2 >= dy){ err += dy; x += sx; }
    if (e2 <= dx){ err += dx; y += sy; }
  }
  return cells;
}

/**
 * ç¡¬é®è”½ FOVï¼ˆæ‰‡å½¢ + è¦–ç·šï¼Œç„¡è»Ÿé®è”½ï¼‰
 * r å®šç¾©ï¼šr=0â†’(1,0) å³/Eï¼›r=2â†’(0,1) ä¸‹/Sï¼›r=4â†’(-1,0) å·¦/Wï¼›r=6â†’(0,-1) ä¸Š/N
 * @param {number} cx     è§’è‰² x
 * @param {number} cy     è§’è‰² y
 * @param {number} cr     æœå‘ r âˆˆ [0..7]ï¼ˆæ¯æ­¥ 45Â°ï¼Œè§’åº¦ = r*45Â°ï¼‰
 * @param {number} angleDeg   æ‰‡å½¢å¤¾è§’ï¼ˆä¾‹ï¼š90ã€120ã€180ï¼‰
 * @param {number} radius     è¦–è·ï¼ˆæ ¼ï¼‰
 * @param {object} opts
 *  - isBlocked(x,y): boolean     // è©²æ ¼æ˜¯å¦ç‚ºé®è”½ç‰©ï¼ˆç‰†ã€äººã€ç…™éœ§â€¦ï¼‰
 *  - includeOpaqueCell: boolean  // æ’åˆ°çš„ã€Œç¬¬ä¸€å€‹é®è”½ç‰©æ ¼ã€æ˜¯å¦ç®—å¯è¦‹ï¼ˆé è¨­ trueï¼‰
 *  - includeStart: boolean       // æ˜¯å¦åŒ…å«è‡ªå·±æ‰€åœ¨æ ¼ï¼ˆé è¨­ falseï¼‰
 * @returns {[number,number][]    å¯è¦‹æ ¼æ¸…å–®
 */
function computeFOVHard(cx, cy, cr, angleDeg, radius, opts = {}){
  const {
    isBlocked = (x,y)=> isWall(x,y) || occupiedByUnit(x,y),
    includeOpaqueCell = true,
    includeStart = false
  } = opts;

  const DEG2RAD = Math.PI / 180;

  // è§’åº¦ç³»çµ±ï¼š0Â° å‘å³ã€90Â° å‘ä¸‹ â€”â€” èˆ‡ r çš„å®šç¾©å°é½Š
  const facingRad = (cr * 45) * DEG2RAD;
  const halfAngle = (angleDeg * DEG2RAD) / 2;
  const EPS = 1e-9;

  const out = [];
  const seen = new Set();

  // ä»¥åŠå¾‘æ–¹æ¡†æƒæå€™é¸æ ¼
  for (let y = cy - radius; y <= cy + radius; y++){
    for (let x = cx - radius; x <= cx + radius; x++){
      if (!inBounds(x, y)) continue;
      if (!includeStart && x === cx && y === cy) continue;

      // â€”â€” ä»¥ã€Œæ ¼ä¸­å¿ƒã€è¨ˆå‘é‡èˆ‡è·é›¢ï¼Œé¿å…å·¦å³ä¸å°ç¨± â€”â€” //
      const dx = (x + 0.5) - (cx + 0.5);
      const dy = (y + 0.5) - (cy + 0.5);
      const dist = Math.hypot(dx, dy);
      if (dist === 0 || dist-.3 > radius + EPS) continue;

      // æ‰‡å½¢è§’åº¦ç¯©é¸ï¼ˆå«å¾®å°å®¹å·®ï¼‰
      const theta = Math.atan2(dy, dx);          // 0=å³ï¼Œ+90Â°=ä¸‹
      const diff  = Math.abs(normAngleRad(theta - facingRad));
      if (diff > halfAngle + EPS) continue;

      // è¦–ç·šé€æ ¼ï¼ˆBresenhamï¼‰
      const path = lineCells(cx, cy, x, y);
      let blocked = false;
      for (let i = 0; i < path.length; i++){
        const [px, py] = path[i];
        if (isBlocked(px, py)){
          if (includeOpaqueCell){
            const key = `${px},${py}`;
            if (!seen.has(key)){ seen.add(key); out.push([px, py]); }
          }
          blocked = true;
          break;
        }
      }

      if (!blocked){
        const key = `${x},${y}`;
        if (!seen.has(key)){ seen.add(key); out.push([x, y]); }
      }
    }
  }
  return out;
}
</script>
</body>
</html>
